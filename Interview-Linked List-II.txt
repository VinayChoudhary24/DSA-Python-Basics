## CYCLE DETEDTION :: In LL when the tail Node "NEXT" Points to a previous Node, it's a cycle.

                                     1. if we visit node Twice then there is a cycle.
                                     2. we use the Tortoise and Rabbit Approach i.e two pointers. where slow moves
                                        one node and fast moves two nodes.
                                     3. when slow and fast pointers meet, we have a cycle.


###Question
You are given a Singly Linked List of integers. Return true if it has a cycle, else return false.

A cycle occurs when a node's next points back to a previous node in the list.

Answer: [Tortoise and Rabbit] [Tortoise and Hare]
# Insert Node at the Head
class ll_rev_rec_Node:
    def __init__(self, value):
        self.data = value
        self.next = None

# Create Empty Linked List
class LinkedList_rev_rec:
    def __init__(self):
        self.head = None

# We create are function Outside the Linked List
def detect_cycle(head):
    slow = head
    fast = head

    while slow != None and fast != None and fast.next != None:
        slow = slow.next
        fast = fast.next.next

        if slow == fast:
            return True
    return False

# Create LL and also it's Nodes without using the other functions like inser_head or insert_tail
ll = LinkedList_rev_rec()
first_node = ll_rev_rec_Node(10)
ll.head = first_node
cycle_node = ll_rev_rec_Node(20)
ll.head.next = cycle_node
ll.head.next.next = ll_rev_rec_Node(30)
ll.head.next.next.next = ll_rev_rec_Node(40)
ll.head.next.next.next.next = ll_rev_rec_Node(50)
ll.head.next.next.next.next.next = cycle_node

# we call out detect function and pass the the ll head
detect_cycle(ll.head)

True



## STARTING POINT/NODE OF LOOP IN A LL
                               1. when we apply two pointers i.e Tortoise and hare algo, when they both meet we 
                                  detect there is a cycle.
                               2. to get the starting node from which loop started, we need to check the 
                                  distance/difference from head and node at which they meet. 
                               3. The distance from head node to the starting node is always equal to the distance
                                  at which both SLOW and FAST pointers meet/node to the loop starting point i.e the 
                                  distance from the node at which they meet to the loop startig node is equal to the 
                                  distance from head node to the loop starting node.       
                               4. once they meet we take two more pointers i and j. i from head node and j from the point
                                  they meet. 
                               5. we move both i and j one step until they both again meet on the same node and that will
                                  be the starting node in loop.        


###Question
Find the starting node of Cycle in LL

Answer:
# Insert Node at the Head
class ll_rev_rec_Node:
    def __init__(self, value):
        self.data = value
        self.next = None

# Create Empty Linked List
class LinkedList_rev_rec:
    def __init__(self):
        self.head = None

# We create are function Outside the Linked List
def detect_cycle_starting_node(head):
    slow = head
    fast = head

    # we track the node where both pointers meet
    collision_node = None
    while slow != None and fast != None and fast.next != None:
        slow = slow.next
        fast = fast.next.next

        if slow == fast:
            # assign collision
            collision_node = slow
            break

    # take another two pointers i and j
    i = head
    j = collision_node

    # we loop until they both meet
    while i != j and i != None and j != None:
        i = i.next
        j = j.next
    # return i node
    return i

# Create LL and also it's Nodes without using the other functions like inser_head or insert_tail
ll = LinkedList_rev_rec()
first_node = ll_rev_rec_Node(10)
ll.head = first_node
cycle_node = ll_rev_rec_Node(20)
ll.head.next = cycle_node
ll.head.next.next = ll_rev_rec_Node(30)
ll.head.next.next.next = ll_rev_rec_Node(40)
ll.head.next.next.next.next = ll_rev_rec_Node(50)
ll.head.next.next.next.next.next = cycle_node

# we call out detect_start function and pass the the ll head
detect_cycle_starting_node(ll.head).data

20



## APPEND LAST N TO FIRST:: Very IMP
                    1. we have a LL and a Integer Value N.
                    2. we need to Move the Last N nodes to the Start of the LL.
                    3. we need to find Three Nodes t(N + 1)th node from Last, y(Tail Node), x(n)th Node from Last.
                    4. After Finding the Three Nodes, we need to follow these steps and update all Three Nodes i.e   
                                                        t=> the node before N i.e (N + 1)th Node from Last, we need to 
                                                            break the connection from t to x(t.next = None). so now t 
                                                            node is the new TAIL Node.
                                                        y=> the y node NEXT will point to HEAD Node i.e y.next = head
                                                        x=> this node will be the new HEAD Node i.e head = x
                    5. In Terms of Two pointers Approach(slow and fast) the above process looks like this::
                                                 # fast moves N nodes for first time and then one node for rest, this
                                                   is very important to maintain the gap between slow and fast.
                                                 # slow moves one node from the starting.
                                                 # t is slow pointer
                                                 # y is fast pointer             
                                                 # x is slow.next
                                               Now, 
                                                 new_head = slow.next, #this is x
                                                 slow.next = None, #we break connection and this is new Tail node
                                                 fast.next = head, #this is y
                                                 head = new_head, #we update the head 


###Question
Append Last N to First

You have been given a singly linked list of integers along with an integer 'N'. Write a function to append 
the last 'N' nodes towards the front of the singly linked list and returns the new head to the list.

Hint:
Identify how many pointers you require and try traversing them to right places and connect nodes accordingly 
also don't forget to disconnect what's required else it could create cycles.

Answer:
# Insert Node at the Head
class ll_rev_rec_Node:
    def __init__(self, value):
        self.data = value
        self.next = None

# Create Empty Linked List
class LinkedList_rev_rec:
    def __init__(self):
        self.head = None

    # func to display LL
    def display_ll(self):
        temp = self.head
        while temp != None:
            print(temp.data, end="-->")
            temp = temp.next
        print("X")

# We create are function Outside the Linked List
def move_last_n_to_first(head, n):
    if head == None or n <= 0:
        # LL is Empty or dont move anything n is 0
        return head
    slow = head
    fast = head

    # fast moves N nodes for first time and then one node for rest, this
    # is very important to maintain the gap between slow and fast.
    for i in range(n):
        fast = fast.next

    # now move slow and fast one node each
    while fast.next != None:
        fast = fast.next
        slow = slow.next

    # once loop is over fast will be at tail and slow will be at (n + 1)th node
    new_head = slow.next # store the remaing nodes
    slow.next = None # we break connection and this is new Tail node
    fast.next = head
    head = new_head # we update the head
    
    return head

# Create LL and also it's Nodes without using the other functions like inser_head or insert_tail
ll = LinkedList_rev_rec()
first_node = ll_rev_rec_Node(9)
ll.head = first_node
ll.head.next = ll_rev_rec_Node(20)
ll.head.next.next = ll_rev_rec_Node(3)
ll.head.next.next.next = ll_rev_rec_Node(49)
ll.head.next.next.next.next = ll_rev_rec_Node(5)
ll.head.next.next.next.next.next = ll_rev_rec_Node(24)

ll.display_ll()
# we call out detect_start function and pass the the ll head
ll.head = move_last_n_to_first(ll.head, 3)
ll.display_ll()                                                             

9-->20-->3-->49-->5-->24-->X
49-->5-->24-->9-->20-->3-->X



## MERGE TWO SORTED LL :: MOST IMPORTANT
                               *****Conditions::
                                     1. given two LL (Sizes can be same or different)
                                     2. which are already sorted in Increasing order

                               *****Expected To Do::
                                     1. Merge both into a Single LL such that the result is also Sorted i.e
                                        in Increasing order.
                                     2. this problem is similar to the one we solve earlier i.e merging to sorted
                                        arrays/list in one.

                               *****Approach 1:: Time and Space Complexity:: O(n + m)
                                     1. we create a brand new LL.
                                     2. loop over both sorted LL, compare the nodes and add at Tail accordingly in the 
                                        new LL. 

                               *****Approach 2:: Takes Advantage of LL(Better Approach)
                                                 Time Complexity:: O(min(n, m))
                                                 Space Complexity :: O(1)
                                     1. we create a DUMMY Node to track, with any random value/data and dummy.next 
                                        is None.
                                     2. for i.data is LESS than j.data, i is looping on LL1 and j on LL2:
                                             if i.data < j.data:
                                                 dummy.next = i, now dummy points to the first node in LL1
                                                 i = i.next, now this moves i to the second node in LL1
                                                 dummy.next.next = None  
                                                 dummy = dummy.next, this moves dummmy to the first node in LL1
                                     3. for i.data is MORE than j.data, i is looping on LL1 and j on LL2:
                                             else:
                                                 dummy.next = j, now dummy points to the first node in LL2
                                                 j = j.next, now this moves j to the second node in LL2
                                                 dummy.next.next = None  
                                                 dummy = dummy.next, this moves dummy to the first node in LL2
                                     4. the above step 2 and 3 works when both LL have nodes but the sizes can be 
                                        different so we check single LL also like we do in merge arrays.
                                     5. if i != None, Nodes remaining in LL1
                                           dummy.next = i, now dummy points to the first node in LL1
                                     6. if j!= None, Nodes remaining in LL2 
                                           dummy.next = j, now dummy points to the first node in LL2
                  


###Question
Merge Two Sorted LL

You have been given two sorted(in ascending order) singly linked lists of integers.

Write a function to merge them in such a way that the resulting singly linked list is also sorted(in ascending order) 
and return the new head to the list.

Note :
Try solving this in O(1) auxiliary space.

No need to print the list, it has already been taken care.

Answer:
# Insert Node at the Head
class ll_rev_rec_Node:
    def __init__(self, value):
        self.data = value
        self.next = None

# Create Empty Linked List
class LinkedList_rev_rec:
    def __init__(self):
        self.head = None

    # func to display LL
    def display_ll(self):
        temp = self.head
        while temp != None:
            print(temp.data, end="-->")
            temp = temp.next
        print("X")

# We create are function Outside the Linked List
def merge_two_sorted_LL(head1, head2):
    # we create a DUMMY Node to track,
    # Create a dummy node to simplify edge cases (acts as placeholder)
    new_head = ll_rev_rec_Node(-1)
    dummy = new_head # Keep reference to dummy node for traversal

    # Initialize pointers for both input lists
    i = head1
    j = head2

    # loop until both LL have Nodes
    while i != None and j != None:
        # If first list's node is smaller
        if i.data < j.data:
            dummy.next = i # Link dummy to the smaller node (from list 1)
            i = i.next # Move pointer in first list forward
        else:
            # If second list's node is smaller or equal
            dummy.next = j # Link dummy to the smaller node (from list 2)
            j = j.next # Move pointer in second list forward
        dummy.next.next = None # Disconnect the newly added node from its original list
        dummy = dummy.next # Move dummy pointer forward to continue building merged list

    # if ll1/head1 exhaust:
    if j != None:
        dummy.next = j # add the remaing directly

    # if ll2/head2 exhaust:
    if i != None:
        dummy.next = i # add the remaing direclty

    # Get the actual merged list (skip the dummy node)
    result = new_head.next
    new_head.next = None # Disconnect dummy node
    # we return the Node itself here
    # Return the head of the merged linked list
    return result

# Create LL and also it's Nodes without using the other functions like inser_head or insert_tail
ll1 = LinkedList_rev_rec()
ll2 = LinkedList_rev_rec()
# LL1
first_node = ll_rev_rec_Node(1)
ll1.head = first_node
ll1.head.next = ll_rev_rec_Node(4)
ll1.head.next.next = ll_rev_rec_Node(13)
ll1.head.next.next.next = ll_rev_rec_Node(29)
ll1.head.next.next.next.next = ll_rev_rec_Node(30)

# LL2
first_node_ll2 = ll_rev_rec_Node(2)
ll2.head = first_node_ll2
ll2.head.next = ll_rev_rec_Node(3)
ll2.head.next.next = ll_rev_rec_Node(9)
ll2.head.next.next.next = ll_rev_rec_Node(39)

ll1.display_ll()
ll2.display_ll()
# we call out detect_start function and pass the the ll head

# Call merge function with both list heads and get the merged list head
new_merged_LL = merge_two_sorted_LL(ll1.head, ll2.head)

# we need to loop on the returned head Node and print 
temp = new_merged_LL
while temp != None:
    print(temp.data, end="-->")
    temp = temp.next
print("X")

1-->4-->13-->29-->30-->X
2-->3-->9-->39-->X
1-->2-->3-->4-->9-->13-->29-->30-->39-->X



## REVERSE LINKED LIST IN K GROUPS:: MOST IMP:: Time Com:: O(n) and Space Com:: O(n/k)
                         *****Condition::
                                  1. given a linked list and a Integer Value k.

                         *****Expected To Do::
                                  1. Reverse LL but in groups of Size K
                                  2. We need to reverse each group separately.
                                  3. if somehow a group size is less than K we do not reverse that particular group.

                         *****Approach::
                                  1. we use Recursion
                                  2. we keep temp variable to get the remaining node value i.e (K + 1)th Node.
                                  3. we keep a count variable to count the number of nodes remaining.
                                  4. if number of nodes is less than K that means this is the last group and it has less
                                     nodes than K so we do not reverse it.
                                  5. we reverse the first group of size k and Assump that recursion will do the rest. 
                                  6. After recursion call we will get a new_head, which we will point to the previous 
                                     head node(After Reverse it is Tail Node Now) of first group of size k reversed.  



###Question
Reverse List in K Groups

You are given a linked list of 'n' nodes and an integer 'k', where 'k' is less than or equal to 'n'.

Your task is to reverse the order of each group of 'k' consecutive nodes, if 'n' is not divisible by 'k', 
then the last group of nodes should remain unchanged.

For example, if the linked list is 1->2->3->4->5, and 'k' is 3, we have to reverse the first three elements, 
and leave the last two elements unchanged. Thus, the final linked list being 3->2->1->4->5.

Implement a function that performs this reversal, and returns the head of the modified linked list.

Answer:
# Insert Node at the Head
class ll_rev_rec_Node:
    def __init__(self, value):
        self.data = value
        self.next = None

# Create Empty Linked List
class LinkedList_rev_rec:
    def __init__(self):
        self.head = None

    # func to display LL
    def display_ll(self):
        temp = self.head
        while temp != None:
            print(temp.data, end="-->")
            temp = temp.next
        print("X")

# ===== HELPER FUNCTION: REVERSE FIRST K NODES =====
# Function to reverse the first k nodes of a linked list (iterative approach)
def reverse_first_k_nodes(head, k):
    prev = None # Initialize previous pointer as None
    curr = head # Start with current pointer at head
    count = 0 # Counter to track number of nodes reversed

    while count < k and curr != None:
        remaining = curr.next # Store next node before changing link
        curr.next = prev # Reverse the link: point current to previous
        prev = curr # Move prev forward to current node
        curr = remaining # Move curr forward to next node
        count += 1 # Increment counter
    return prev # Return new head of the reversed group (was the kth node)

# ===== MAIN RECURSIVE FUNCTION: REVERSE IN GROUPS OF K =====
# Recursive function to reverse linked list in groups of size k
def k_reverse_rec(head, k):
    # base case 
    if head == None:
        return None

    temp = head # Temporary pointer to traverse and count nodes
    count = 0 # Counter for number of available nodes
    # ===== STEP 1: Count if we have at least k nodes remaining=====
    while count < k and temp != None:
        temp = temp.next  # Move to next node
        count += 1  # Increment counter

    # If we have fewer than k nodes, don't reverse (last incomplete group)
    if count < k:
        return head # Return head as-is for the last group

    # esle we reverse
    # ===== STEP 2: REVERSE CURRENT GROUP (SELF WORK) =====
    # we get the group head
    group_head = reverse_first_k_nodes(head, k) # Self work Done
    # After reversal:
    # - group_head points to new head of reversed group (was kth node)
    # - head now points to first node of group (now tail after reversal)
    # - temp points to (k+1)th node (start of next group)

    # ===== STEP 3: RECURSIVE CALL FOR REMAINING NODES =====
    # INDUCTION ASSUMPTION: Assume recursion will correctly reverse remaining groups
    # Connect tail of current reversed group to head of next reversed group
    # head.next connects the already reversed group Tail to the Current group head i.e tail.next points Current group head
    head.next = k_reverse_rec(temp, k)
    # Explanation:
    # - 'head' is now the TAIL of current reversed group
    # - 'temp' points to start of next group
    # - Recursive call reverses remaining groups and returns their head
    # - We connect current tail to that head

    # ===== STEP 4: RETURN NEW HEAD =====
    return group_head # Return head of current reversed group
    

# Create LL and also it's Nodes without using the other functions like inser_head or insert_tail
ll1 = LinkedList_rev_rec()
# LL1
first_node = ll_rev_rec_Node(1)
ll1.head = first_node
ll1.head.next = ll_rev_rec_Node(4)
ll1.head.next.next = ll_rev_rec_Node(13)
ll1.head.next.next.next = ll_rev_rec_Node(29)
ll1.head.next.next.next.next = ll_rev_rec_Node(30)
ll1.head.next.next.next.next.next = ll_rev_rec_Node(44)
ll1.head.next.next.next.next.next.next = ll_rev_rec_Node(83)
ll1.head.next.next.next.next.next.next.next = ll_rev_rec_Node(9)

ll1.display_ll()
# we call out detect_start function and pass the the ll head
# Call function to reverse list in groups of 3
result_head_node = k_reverse_rec(ll1.head, 3)
# we need to loop on the returned head Node and print 
temp = result_head_node
while temp != None:
    print(temp.data, end="-->")
    temp = temp.next
print("X")

1-->4-->13-->29-->30-->44-->83-->9-->X
13-->4-->1-->44-->30-->29-->83-->9-->X


########################################### DOUBLY LINKED LIST #########################################
########################################################################################################

## In Doubly LL we can Traverse in both directions from Head to Tail and Tail to Head.
   --In Singly LL we have two properties, data and next. 
   --In Doubly LL we add one more property, data, next and previous.
   --The Previous property contains the Memory Address of the previous Node.

## Advantage of Doubly LL
                       1. at any point of time we can traverse from right to left i.e Tail to Head.
                       2. we move left to right using node.next and we move right to left using node.previous.



### Insert node at the head of the doubly Linked List

# creating doubly LL Node
class doubly_ll_node:
    def __init__(self, value):
        self.data = value
        self. next = None
        self.previous = None

    
class doubly_linked_list:
    def __init__(self):
        self.head = None

    def insert_at_db_head(self, data):
        # create node
        new_doubly_node = doubly_ll_node(data)
        
        if self.head == None:
            self.head = new_doubly_node
            return

        # assign the current head previous to the new db node
        self.head.previous = new_doubly_node

        # assign the new db node next to the current head
        new_doubly_node.next = self.head

        # update the head
        self.head = new_doubly_node

    # func to display LL
    def display_ll(self):
        temp = self.head
        while temp != None:
            print(temp.data, end="-->")
            temp = temp.next
        print("X")

ll2 = doubly_linked_list()

ll2.insert_at_db_head(8)
ll2.insert_at_db_head(1)
ll2.insert_at_db_head(10)
ll2.insert_at_db_head(7)
ll2.display_ll()

7-->10-->1-->8-->X



### Insert node at the tail of the Doubly LL

###Question
A doubly-linked list is a data structure that consists of sequentially linked nodes, and the nodes have 
reference to both the previous and the next nodes in the sequence of nodes.

Given a doubly-linked list and a value ‘k’, insert a node having value ‘k’ at the end of the doubly linked list.

Note:
You need not print anything. You’re given the head of the linked list. Return the head of the modified list.

Answer:

# creating doubly LL Node
class doubly_ll_node:
    def __init__(self, value):
        self.data = value
        self. next = None
        self.previous = None

    
class doubly_linked_list:
    def __init__(self):
        self.head = None

    def insert_at_db_tail(self, data):
        # create node
        new_doubly_node = doubly_ll_node(data)
        
        if self.head == None:
            self.head = new_doubly_node
            return

        # loop until tail node
        temp = self.head
        while temp.next != None:
            temp = temp.next

        # now temp is the tail node
        # assign the tail node next to new node
        temp.next = new_doubly_node

        # assign the previous of newly node to temp
        new_doubly_node.previous = temp

    # func to display LL
    def display_ll(self):
        temp = self.head
        while temp != None:
            print(temp.data, end="-->")
            temp = temp.next
        print("X")

ll2 = doubly_linked_list()

ll2.insert_at_db_tail(8)
ll2.insert_at_db_tail(1)
ll2.insert_at_db_tail(10)
ll2.insert_at_db_tail(7)
ll2.display_ll()

8-->1-->10-->7-->X



###Question
Insert the node in the middle of the Doubly LL

Answer:
# creating doubly LL Node
class doubly_ll_node:
    def __init__(self, value):
        self.data = value
        self. next = None
        self.previous = None

    
class doubly_linked_list:
    def __init__(self):
        self.head = None

    def insert_at_db_middle(self, value, pos):
        # create node
        new_doubly_node = doubly_ll_node(value)
        # Case 1: empty list
        if self.head == None:
            self.head = new_doubly_node
            return

        # Case 2: inserting at head
        if pos == 0:
            new_doubly_node.next = self.head
            self.head.previous = new_doubly_node
            self.head = new_doubly_node
            return

        temp = self.head
        i = 0
        # get the node previous to the pos node i.e # move to position - 1
        while temp.next != None and i < pos - 1:
            temp = temp.next
            i += 1

        # now temp is at the previous node to pos node
        remaining = temp.next

        # add the new node to previous node next
        temp.next = new_doubly_node
        new_doubly_node.previous = temp
        new_doubly_node.next = remaining

        if remaining != None:
            remaining.previous = new_doubly_node
        

    # func to display LL
    def display_ll(self):
        temp = self.head
        while temp != None:
            print(temp.data, end="-->")
            temp = temp.next
        print("X")

ll2 = doubly_linked_list()
ll2.insert_at_db_middle(1, 2)
ll2.insert_at_db_middle(3, 0)
ll2.insert_at_db_middle(2, 0)
ll2.insert_at_db_middle(6, 1)
ll2.insert_at_db_middle(8, 5)

ll2.display_ll()

2-->6-->3-->1-->X



###Question
Delete at the head of the Doubly LL

Answer:
# creating doubly LL Node
class doubly_ll_node:
    def __init__(self, value):
        self.data = value
        self. next = None
        self.previous = None

    
class doubly_linked_list:
    def __init__(self):
        self.head = None

    def insert_at_db_tail(self, data):
        # create node
        new_doubly_node = doubly_ll_node(data)
        
        if self.head == None:
            self.head = new_doubly_node
            return

        # loop until tail node
        temp = self.head
        while temp.next != None:
            temp = temp.next

        # now temp is the tail node
        # assign the tail node next to new node
        temp.next = new_doubly_node

        # assign the previous of newly node to temp
        new_doubly_node.previous = temp

    def delete_at_db_head(self):
        # Case 1 LL is Empty
        if self.head == None:
            return

        # Case 2 there is only one node
        if self.head.next == None:
            self.head = None
            return

        # case 3 delete at head
        new_head = self.head.next

        # break the current head connection
        # self.head.next = None

        # update the new head
        self.head = new_head
        self.head.previous = None

    # func to display LL
    def display_ll(self):
        temp = self.head
        while temp != None:
            print(temp.data, end="-->")
            temp = temp.next
        print("X")

ll2 = doubly_linked_list()

ll2.insert_at_db_tail(8)
ll2.insert_at_db_tail(1)
ll2.insert_at_db_tail(10)
ll2.insert_at_db_tail(7)
ll2.display_ll()

ll2.delete_at_db_head()
ll2.display_ll()

8-->1-->10-->7-->X
1-->10-->7-->X



###Question
Delete at the tail of the doubly LL

A doubly-linked list is a data structure that consists of sequentially linked nodes, and the nodes have 
reference to both the previous and the next nodes in the sequence of nodes.

Given a doubly-linked list, delete the node at the end of the doubly linked list.

Note:
You need not print anything. You’re given the head of the linked list, just return the head of the modified list.

Answer:
# creating doubly LL Node
class doubly_ll_node:
    def __init__(self, value):
        self.data = value
        self. next = None
        self.previous = None

    
class doubly_linked_list:
    def __init__(self):
        self.head = None

    def insert_at_db_tail(self, data):
        # create node
        new_doubly_node = doubly_ll_node(data)
        
        if self.head == None:
            self.head = new_doubly_node
            return

        # loop until tail node
        temp = self.head
        while temp.next != None:
            temp = temp.next

        # now temp is the tail node
        # assign the tail node next to new node
        temp.next = new_doubly_node

        # assign the previous of newly node to temp
        new_doubly_node.previous = temp

    def delete_at_db_tail(self):
        # Case 1 LL is Empty
        if self.head == None:
            return

        # case 2 there is only one node
        if self.head.next == None:
            self.head = None
            return

        # case 3 delete at tail
        temp = self.head
        # get the node before tail node
        while temp.next.next != None:
            temp = temp.next

        # now temp is the prev node before tail
        tail = temp.next
        tail.previous = None  # break backwardconnection
    
        temp.next = None      # remove last node
        

    # func to display LL
    def display_ll(self):
        temp = self.head
        while temp != None:
            print(temp.data, end="-->")
            temp = temp.next
        print("X")

ll2 = doubly_linked_list()

ll2.insert_at_db_tail(8)
ll2.insert_at_db_tail(1)
ll2.insert_at_db_tail(10)
ll2.insert_at_db_tail(7)
ll2.display_ll()

ll2.delete_at_db_tail()
ll2.display_ll()

8-->1-->10-->7-->X
8-->1-->10-->X




###Question
Delete at the middle of the doubly LL

Answer:
# creating doubly LL Node
class doubly_ll_node:
    def __init__(self, value):
        self.data = value
        self. next = None
        self.previous = None

    
class doubly_linked_list:
    def __init__(self):
        self.head = None

    def insert_at_db_tail(self, data):
        # create node
        new_doubly_node = doubly_ll_node(data)
        
        if self.head == None:
            self.head = new_doubly_node
            return

        # loop until tail node
        temp = self.head
        while temp.next != None:
            temp = temp.next

        # now temp is the tail node
        # assign the tail node next to new node
        temp.next = new_doubly_node

        # assign the previous of newly node to temp
        new_doubly_node.previous = temp

    def delete_at_db_middle(self, pos):
        # Case 1 LL is Empty
        if self.head == None:
            return

        # case 2 
        if pos == 0:
            if self.head.next is None:
                self.head = None
                return
            new_head = self.head.next
            new_head.previous = None
            self.head = new_head
            return

        # case 3 
        temp = self.head
        i = 0
        # loop and get the node before pos 
        while temp.next != None and i < pos - 1:
            temp = temp.next
            i += 1

        # position out of bounds
        if temp is None or temp.next is None:
            return
        
        # now temp is previous node
        node_to_delete = temp.next

        # update the remaing node previous i.e skip the
        remaining = node_to_delete.next

        # If deleting last node
        if remaining is None:
            temp.next = None
            return

        # Deleting a middle node
        # skip the node to delete and update temp.next
        temp.next = remaining
        remaining.previous = temp

        
    # func to display LL
    def display_ll(self):
        temp = self.head
        while temp != None:
            print(temp.data, end="-->")
            temp = temp.next
        print("X")

ll2 = doubly_linked_list()

ll2.insert_at_db_tail(8)
ll2.insert_at_db_tail(1)
ll2.insert_at_db_tail(10)
ll2.insert_at_db_tail(7)
ll2.display_ll()

ll2.delete_at_db_middle(0)
ll2.display_ll()

8-->1-->10-->7-->X
1-->10-->7-->X

########################################### DOUBLY LINKED LIST #########################################
########################################################################################################




########################################### CIRCULAR LINKED LIST #######################################
########################################################################################################
--In Singly Circular LL, where the Tail.next points to the head.

--In Doubly Circular LL, where the Tail.next points to the head and head.previous points to the tail.



###Question
Insert at the head of the Circular Linked List

Answer:
class Circular_Node:
    def __init__(self, value):
        self.data = value
        self.next = None

class Circular_LL:
    def __init__(self):
        self.head = None
        self.tail = None

    def add_at_circ_head(self, value):
        new_circ_node = Circular_Node(value)
        if self.head == None:
            self.head = new_circ_node
            self.tail = new_circ_node

        # get the current head
        new_circ_node.next = self.head

        # update the head
        self.head = new_circ_node

        # add prev to current head
        self.tail.next = self.head

    # func to display LL
    def display_ll(self):
        temp = self.head
        while temp != self.tail:
            print(temp.data, end="-->")
            temp = temp.next
        # when the loop ends temp is at tail and we print that
        print(temp.data, end="--Points-to-head-->>")
        print(temp.next.data)

cl = Circular_LL()
cl.add_at_circ_head(1)
cl.add_at_circ_head(2)
cl.add_at_circ_head(3)

cl.display_ll()

3-->2-->1--Points-to-head-->>3



###Question
You’re given a linked list. The last node might point to null, or it might point to a node in the list, 
thus forming a cycle.

Find out whether the linked list has a cycle or not, and the length of the cycle if it does.

If there is no cycle, return 0, otherwise return the length of the cycle.

Answer:

# Insert Node at the Head
class ll_rev_rec_Node:
    def __init__(self, value):
        self.data = value
        self.next = None

# Create Empty Linked List
class LinkedList_rev_rec:
    def __init__(self):
        self.head = None

    # func to display LL
    def display_ll(self):
        temp = self.head
        while temp != None:
            print(temp.data, end="-->")
            temp = temp.next
        print("X")

# We create are function Outside the Linked List
# Function to detect if a cycle exists and return its length
def detect_cycle_length(head):
    if head is None:
        return 0

    slow = head
    fast = head

    while slow != None and fast != None and fast.next != None:
        slow = slow.next # Move slow pointer by 1 step
        fast = fast.next.next # Move fast pointer by 2 steps

        # If slow and fast pointers meet, a cycle exists
        if slow == fast:
            # Find cycle length
            length = 1 # Initialize cycle length counter
            temp = slow.next # Start from the next node after meeting point

            # Traverse the cycle until we return to the meeting point
            while temp != slow:
                temp = temp.next # Move to next node in cycle
                length += 1 # Increment cycle length counter

            return length  # Return the calculated cycle length

    # If we exit the loop, no cycle was detected
    return 0

# Create LL and also it's Nodes without using the other functions like inser_head or insert_tail
ll = LinkedList_rev_rec()
first_node = ll_rev_rec_Node(10)
ll.head = first_node
cycle_node = ll_rev_rec_Node(20)
ll.head.next = cycle_node
ll.head.next.next = ll_rev_rec_Node(30)
ll.head.next.next.next = ll_rev_rec_Node(40)
ll.head.next.next.next.next = ll_rev_rec_Node(50)
ll.head.next.next.next.next.next = cycle_node
# ll.display_ll()
# we call out detect function and pass the the ll head
detect_cycle_length(ll.head)

4



###Question
Delete Every N nodes

You have been given a singly linked list of integers along with two integers, 'M,' and 'N.' Traverse the 
linked list such that you retain the 'M' nodes, then delete the next 'N' nodes. Continue the same until the 
end of the linked list. Indexing starts from 1.

To put it in other words, in the given linked list, you need to delete N nodes after every M nodes.

Note :
No need to print the list, it has already been taken care. Only return the new head to the list. You can return 
null in case where all nodes will be deleted.

Answer:

# Insert Node at the Head
class ll_rev_rec_Node:
    def __init__(self, value):
        self.data = value
        self.next = None

# Create Empty Linked List
class LinkedList_rev_rec:
    def __init__(self):
        self.head = None

    # func to display LL
    def display_ll(self):
        temp = self.head
        while temp != None:
            print(temp.data, end="-->")
            temp = temp.next
        print("X")

# We create are function Outside the Linked List
# Function to skip M nodes and delete N nodes alternately
# Pattern: Keep M nodes -> Delete N nodes -> Keep M nodes -> Delete N nodes...
def skipMdeleteN(head, M, N) :
    # Edge case: if list is empty, return None
    if head is None:
        return None

    # If M is 0 ? delete entire list
    # Special case: if M is 0, we should delete the entire list
    # (skip 0 means delete everything)
    if M == 0:
        return None

    temp = head

    # Continue until we've processed the entire list
    while temp != None:
        # Step 1: Skip M-1 nodes (we're already at the 1st node, so skip M-1 more)
        # This loop moves temp to the M-th node that we want to keep
        for _ in range(1, M):
            if temp is None: # If we run out of nodes while skipping
                return head # Return the modified list
            
            temp = temp.next # Move to the next node

        # Now temp is positioned at the M-th node (the last node to keep)
        if temp is None: # If temp is None, we've reached the end
            return head # Return the modified list
        
        # Step 2: Start deleting the next N nodes
        # del_ptr points to the first node we want to delete
        del_ptr = temp.next
        # Loop N times to skip over the nodes we want to delete
        for _ in range(N):
            if del_ptr is None: # If we run out of nodes before deleting N nodes
                break # Exit the deletion loop early
            
            del_ptr = del_ptr.next # Move to the next node (skipping/deleting current)

        # Connect the M-th node (temp) to the node after the N deleted nodes (del_ptr)
        # This effectively removes the N nodes from the linked list
        temp.next = del_ptr

        # Move temp to the next valid node to continue the pattern
        # This becomes the start of the next M-node segment to keep
        temp = del_ptr

    return head # Return the head of the modified list

# Create LL and also it's Nodes without using the other functions like inser_head or insert_tail
ll = LinkedList_rev_rec()
first_node = ll_rev_rec_Node(10)
ll.head = first_node
ll.head.next = ll_rev_rec_Node(20)
ll.head.next.next = ll_rev_rec_Node(30)
ll.head.next.next.next = ll_rev_rec_Node(40)
ll.head.next.next.next.next = ll_rev_rec_Node(50)
ll.head.next.next.next.next.next = ll_rev_rec_Node(60)
ll.head.next.next.next.next.next.next = ll_rev_rec_Node(70)
ll.head.next.next.next.next.next.next.next = ll_rev_rec_Node(80)
ll.display_ll()
# we call out detect function and pass the the ll head
ll.head = skipMdeleteN(ll.head, 2, 3)
ll.display_ll()

10-->20-->30-->40-->50-->60-->70-->80-->X
10-->20-->60-->70-->X



###Question
Swap Two Nodes of Linked List

You have been given a singly linked list of integers along with two integers, 'i,' and 'j.' Swap the nodes 
that are present at the 'i-th' and 'j-th' positions and return the new head to the list.

Note :
1. Remember, You need to swap the nodes, not only the data.
2. Indexing starts from 0.
3. No need to print the list, it has already been taken care.

Answer:

# Insert Node at the Head
class ll_rev_rec_Node:
    def __init__(self, value):
        self.data = value
        self.next = None

# Create Empty Linked List
class LinkedList_rev_rec:
    def __init__(self):
        self.head = None

    # func to display LL
    def display_ll(self):
        temp = self.head
        while temp != None:
            print(temp.data, end="-->")
            temp = temp.next
        print("X")

# We create are function Outside the Linked List
# Function to swap two nodes at positions i and j in the linked list
# This swaps the actual nodes, not just their values
def swapNodes(head, i, j):
    # Edge case: If list is empty or swapping same position, return unchanged
    if head is None or i == j:
        return head

    # Ensure i < j for simpler handling (swap i and j if needed)
    # This makes sure we always process the earlier node first
    if i > j:
        i, j = j, i

    # Initialize pointers to find nodes at positions i and j
    prev1 = prev2 = None # Pointers to nodes BEFORE positions i and j
    curr1 = curr2 = head # Pointers to nodes AT positions i and j
    pos = 0 # Position counter

    # Step 1: Find the node at index i and its previous node
    while curr1 is not None and pos < i:
        prev1 = curr1 # Keep track of the previous node
        curr1 = curr1.next # Move to the next node
        pos += 1 # Increment position counter

    # Step 2: Find the node at index j and its previous node
    pos = 0 # Reset position counter to start from head again
    while curr2 is not None and pos < j:
        prev2 = curr2 # Keep track of the previous node
        curr2 = curr2.next # Move to the next node
        pos += 1 # Increment position counter

    # Edge case: If either position doesn't exist in the list, return unchanged
    # This happens if i or j is beyond the list length
    if curr1 is None or curr2 is None:
        return head

    # Step 3: Update the previous node's next pointer for node at position i
    # If curr1 is NOT the head node (has a previous node)
    if prev1 is not None:
        prev1.next = curr2 # Point prev1 to curr2 (swapping connection)
    else:
        # If curr1 IS the head, curr2 becomes the new head
        head = curr2   # curr2 becomes new head

    # Step 4: Update the previous node's next pointer for node at position j
    # If curr2 is NOT the head node (has a previous node)
    if prev2 is not None:
        prev2.next = curr1 # Point prev2 to curr1 (swapping connection)
    else:
        # If curr2 IS the head, curr1 becomes the new head
        head = curr1   # curr1 becomes new head

    # Step 5: Swap the next pointers of curr1 and curr2
    # This completes the node swap by exchanging what each node points to
    temp = curr1.next # Temporarily store curr1's next pointer
    curr1.next = curr2.next # curr1 now points to what curr2 was pointing to
    curr2.next = temp # curr2 now points to what curr1 was pointing to

    return head


# Create LL and also it's Nodes without using the other functions like inser_head or insert_tail
ll = LinkedList_rev_rec()
first_node = ll_rev_rec_Node(10)
ll.head = first_node
ll.head.next = ll_rev_rec_Node(20)
ll.head.next.next = ll_rev_rec_Node(30)
ll.head.next.next.next = ll_rev_rec_Node(40)
ll.head.next.next.next.next = ll_rev_rec_Node(50)
ll.head.next.next.next.next.next = ll_rev_rec_Node(60)
ll.head.next.next.next.next.next.next = ll_rev_rec_Node(70)
ll.head.next.next.next.next.next.next.next = ll_rev_rec_Node(80)
ll.display_ll()
# we call out detect function and pass the the ll head
ll.head = swapNodes(ll.head, 1, 3)
ll.display_ll()

10-->20-->30-->40-->50-->60-->70-->80-->X
10-->40-->30-->20-->50-->60-->70-->80-->X



###Question
Even After odd LL

For a given singly linked list of integers, arrange the nodes such that all the even number nodes are placed 
after the all odd number nodes. The relative order of the odd and even terms should remain unchanged.

Note :
1. No need to print the linked list, it has already been taken care. Only return the new head to the list.
2. Don't create a new linked list.
3.  Just change the data, instead rearrange the provided list.

Answer:

# Insert Node at the Head
class ll_rev_rec_Node:
    def __init__(self, value):
        self.data = value
        self.next = None

# Create Empty Linked List
class LinkedList_rev_rec:
    def __init__(self):
        self.head = None

    # func to display LL
    def display_ll(self):
        temp = self.head
        while temp != None:
            print(temp.data, end="-->")
            temp = temp.next
        print("X")

# We create are function Outside the Linked List
# Function to rearrange linked list so all odd numbers come before even numbers
# This maintains the relative order within odd and even groups
def evenAfterOdd(head):
    # Edge case: If list is empty, return None
    if head is None:
        return None

    # Initialize four pointers to build two separate lists:
    # - odd_head: points to the first odd number node
    # - odd_tail: points to the last odd number node (for appending)
    # - even_head: points to the first even number node
    # - even_tail: points to the last even number node (for appending)
    odd_head = odd_tail = None
    even_head = even_tail = None

    curr = head

    # Traverse through the entire linked list
    while curr:
        # Save the next node before we modify curr.next
        # This is important because we'll detach curr from the original list
        next_node = curr.next

        # Detach current node from the original list
        # This isolates the node so we can add it to either odd or even list
        curr.next = None  

        # Check if current node's data is odd (remainder is not 0 when divided by 2)
        if curr.data % 2 != 0:
            # Current node contains an odd number

            # If this is the first odd node we've encountered
            if odd_head is None:
                # Set both head and tail to this node (list has only one node)
                odd_head = odd_tail = curr
            else:
                # Append current node to the end of the odd list
                odd_tail.next = curr # Link the previous tail to current node
                odd_tail = curr # Update tail to point to current node

        else:
            # Current node contains an even number

            # If this is the first even node we've encountered
            if even_head is None:
                # Set both head and tail to this node (list has only one node)
                even_head = even_tail = curr
            else:
                # Append current node to the end of the even list
                even_tail.next = curr # Link the previous tail to current node
                even_tail = curr # Update tail to point to current node

        # Move to the next node in the original list
        curr = next_node

    # Edge case: If there are no odd nodes in the list
    # Return the even list as is (all nodes are even)
    if odd_head is None:
        return even_head

    # Connect the odd list to the even list
    # The last node of the odd list should point to the first node of the even list
    odd_tail.next = even_head

    # Return the head of the odd list (which is now the head of the combined list)
    return odd_head


# Create LL and also it's Nodes without using the other functions like inser_head or insert_tail
ll = LinkedList_rev_rec()
first_node = ll_rev_rec_Node(2)
ll.head = first_node
ll.head.next = ll_rev_rec_Node(1)
ll.head.next.next = ll_rev_rec_Node(3)
ll.head.next.next.next = ll_rev_rec_Node(4)
ll.head.next.next.next.next = ll_rev_rec_Node(5)
ll.head.next.next.next.next.next = ll_rev_rec_Node(7)
ll.head.next.next.next.next.next.next = ll_rev_rec_Node(10)
ll.head.next.next.next.next.next.next.next = ll_rev_rec_Node(80)
ll.display_ll()
# we call out detect function and pass the the ll head
ll.head = evenAfterOdd(ll.head)
ll.display_ll()

2-->1-->3-->4-->5-->7-->10-->80-->X
1-->3-->5-->7-->2-->4-->10-->80-->X



###Question
Delete all occurences of a given key in doubly LL

A doubly-linked list is a data structure that consists of sequentially linked nodes, and the nodes have reference 
to both the previous and the next nodes in the sequence of nodes.

You’re given a doubly-linked list and a key 'k'.

Delete all the nodes having data equal to ‘k’.

Answer:

# creating doubly LL Node
class doubly_ll_node:
    def __init__(self, value):
        self.data = value
        self. next = None
        self.previous = None

    
class doubly_linked_list:
    def __init__(self):
        self.head = None

    def insert_at_db_tail(self, data):
        # create node
        new_doubly_node = doubly_ll_node(data)
        
        if self.head == None:
            self.head = new_doubly_node
            return

        # loop until tail node
        temp = self.head
        while temp.next != None:
            temp = temp.next

        # now temp is the tail node
        # assign the tail node next to new node
        temp.next = new_doubly_node

        # assign the previous of newly node to temp
        new_doubly_node.previous = temp

        
    # func to display LL
    def display_ll(self):
        temp = self.head
        while temp != None:
            print(temp.data, end="-->")
            temp = temp.next
        print("X")

# Function to delete all occurrences of a given value k from the doubly linked list
def deleteAllOccurrences(head, k):
    temp = head

    # Traverse through the entire doubly linked list
    while temp is not None:
        # Step 1: Save the next node before we potentially delete the current node
        # This is crucial because if we delete temp, we'll lose access to temp.next
        next_node = temp.next
        
        # Step 2: Check if the current node's data matches k (value to delete)
        if temp.data == k:
            
            # Case 1: Deleting the head node (first node in the list)
            if temp.previous is None:
                # Update head to point to the next node
                head = next_node
                # If the new head exists (list is not empty after deletion)
                if next_node:        # ensure not None
                    # Set the new head's previous pointer to None
                    # (since it's now the first node)
                    next_node.previous = None

            # Case 2: Deleting a middle or tail node (not the head)
            else:
                # Link the previous node directly to the next node
                # This bypasses (removes) the current node from the chain
                temp.previous.next = next_node
                # If next_node exists (we're not deleting the tail)
                if next_node:
                    # Update next_node's previous pointer to skip the current node
                    next_node.previous = temp.previous

            # Step 3: Break the links of the deleted node (clean up)
            # This disconnects the node completely from the list
            temp.previous = None
            temp.next = None

        # Step 4: Move to the next node in the list (using saved reference)
        temp = next_node

    # Return the (possibly updated) head of the list
    return head

ll2 = doubly_linked_list()

ll2.insert_at_db_tail(8)
ll2.insert_at_db_tail(1)
ll2.insert_at_db_tail(8)
ll2.insert_at_db_tail(10)
ll2.insert_at_db_tail(7)
ll2.insert_at_db_tail(8)
ll2.insert_at_db_tail(9)
ll2.insert_at_db_tail(8)
ll2.insert_at_db_tail(8)

ll2.display_ll()

ll2.head = deleteAllOccurrences(ll2.head, 8)
ll2.display_ll()

8-->1-->8-->10-->7-->8-->9-->8-->8-->X
1-->10-->7-->9-->X